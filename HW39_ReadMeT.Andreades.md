# Порівняння алгоритмів

Для суми `113` монетами номіналами `[50, 25, 10, 5, 2, 1]` було отримано наступні результати:

| Метод                 | Результат                                |
|----------------------|-----------------------------------------|
| Жадібний алгоритм    | `{50: 2, 10: 1, 2: 1, 1: 1}`            |
| Динамічне програмування | `{50: 2, 10: 1, 2: 1, 1: 1}`         |

Обидва алгоритми повернули однаковий результат для заданої суми, що демонструє їхню здатність ефективно розраховувати необхідну кількість монет різних номіналів для видачі решти. Однак, варто зауважити, що алгоритм динамічного програмування може бути більш ефективним у випадках, коли жадібний алгоритм не знаходить оптимального розв'язку через свою локально оптимальну стратегію вибору. Динамічне програмування розглядає всі можливі комбінації, щоб знайти глобально оптимальне рішення.  Це підтверджує, що для деяких задач і наборів даних жадібний алгоритм може бути таким же ефективним, як і алгоритм динамічного програмування.
Тому, хоча в цьому конкретному випадку обидва методи дали однаковий результат, в інших сценаріях (особливо при великих сумах або коли набір монет має специфічні обмеження) динамічне програмування може виявитися більш ефективним за кількістю монет, що використовуються, або за часом виконання, оскільки воно гарантує знаходження оптимального рішення.